package com.jieming;

public class AboutMq {
    /*
    * 线上百万mq消息积压的快速处理方案：
    *   可能导致消息积压的原因：1 消费者代码中的bug
    *                      2 消费者端使用的的中间件存在性能问题
    *   处理方案：
    *         1 优化消费者的代码：由于消费者是消费速度不够导致mq消费积压，将消费者的代码做优化
    *                         a 减少不必要的计算
    *                         b 采用多线程的方式消费
    *                       最终目的：提高消费者的速度。
    *           假设优化前消费者机器有两台，代码优化前处理消息每台消费者 200条/秒，优化后是 400条/秒
    *           如此优化后每小时可以多处理 400×60×60 = 1440000条 ，所以即使 mq的生产的消息包哦重原本不增加的情况
    *           也需要一小时才能多利完，线上一些特殊的业务不允许这样的延迟
    *
    *         2 新建临时topic：如果原本的topic使两个分区，消费者消费的业务逻辑是将数据持久化这种相对耗时的操作
    *              调整消费者的代码为，消费者不做实际的业务处理，而是将消息转发到临时topic，且在临时的topic中增加原本
    *              若干倍的分区，增加临时的机器来消费临时topic上的消息，将原本的业务逻辑放在临时的消费者机器中完成
    *           方案二注意点： 1 增加了临时topic和临时消费者机器，数据库法可能会承受不住压力而崩溃，所以最好做一些数据库保护措施
    *                       2 针对一些设置了失效时间的mq消息，由于积压在mq队列中的时间过长已经失效，
    *                        为了保证消息不丢失，需要手动的处理业务数据
    *                       3 消息积压可能会导致某些分区无法再存储新生产的消息，导致消息丢失，也需要手动的处理业务
    *         3 采取只增加消费者机器而不做分区扩容，该方法不能用在（中间件性能场景），因为即使增加了消费者，消费速度还是很慢
    *
    *   故线上mq消息大量积压问题，预防措施：1 做好数据到达一定量后做告警（包括发送邮件和发送短信到负责人）
    *                                2 然后排查和解决消费者问题
    *                                3 如果做了步骤2后 依旧还存在大量消息积压的问题，在采用新建临时topic方式快速解决消费积压问题
    *
    *
    *
    *
    *
    *
    * */
}
