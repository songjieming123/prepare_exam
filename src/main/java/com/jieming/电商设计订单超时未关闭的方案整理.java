package com.jieming;

public class 电商设计订单超时未关闭的方案整理 {
    /*
    * 电商企业在客户下订单后一般15分钟内未支付，就会执行关闭订单操作，针对超时未支付，删除，一般有一下几种方案：
    *  1 jdk 自带的延迟队列-- delayQueue
    *      用户下单会否将用户的超时订单信息放入延迟队列，然后启动一个线程轮询延迟队列头部，如果发现订单已超时，
    *      就将订单取出来做超时处理。
    *    延迟队列DelayQueue属于jdk曾层的队列，如果在jvm重启后队列中的数据就会丢失。所以为了防止jvm重启数据丢失的问题
    *    每次系统重启都需要将未支付的订单同步到延迟队列
    *    优点：
    *       1 简单，jdk自带的队列，2 易上手，成本低
    *    缺点：
    *       1 订单量大的时候，占用的内存极多，2 任务只能由本机自己消费，无法被其他机器辅助消费
    *
    *  2 rocketMq
    *      rocketmq自带的很重要的延迟队列功能，用户下单后保存订单消息到数据库，然后发送一个消息到延迟队列
    *      rocketMq会自动的在指定时间内出发厌恶处理
    *    优点：
    *       1 使用简单
    *       2 支持分布式
    *       3 出发任务时间精确度高
    *    缺点：
    *       1 rocketmq的延迟时限右限制，最大24小时
    *       2 大量的延迟任务需要很大的mq存储成本
    *       3 同一时刻右大量的任务出发，会造成延迟的时间不准确
    *  3 redis延迟--redis过期通知机制
    *    通过redis该佛其机制，将订单id做key 设置过期时间，然后达到过期时间后，redis会发送一个通知给服务器
    *    缺点：
    *      1 延迟出发时间不精确（redis的过期策略有关）
    *      2 大量的延迟任务需要很大的存储成本
    *
    *
    *  4 基于redis的zset方案
    *     member设置为订单号，score设置为订单超时时间的时间戳（下单时间 + 超时时长）， redis 会对
    *     zset 按照score延迟时间进行排序，然后使用定时任务获取大于socre的值的任务，找到任务订单号，做相关的业务处理
    *    优点：1 实现简单，数据不易丢失， 2 高可用
    *    缺点：1 高并发下的系统吞吐量低
    *
    *  5 任务中心方案：
    *    用户下单后将订单数据保存在订单库，如果订单需要实现延迟任务，此时将订单数据同步一份到任务中心，任务中心通过定时任务，
    *    比如（xxl -job）等触发任务相关操作。
    *    任务中心实质就是把需要实现延迟任务的数据放在一个发单独的任务中心，这样目的是防止定时任务扫描的时候影响正常的订单业务
    *    定时任务会按照一定的频率（比如2秒）扫表拉取满足条件任务（达到任务超时时间的数据），然后执行相关逻辑
    *    优点：
    *       1 使用简单 2 效率高、稳定性强、维护成本低
    *    缺点：
    *       1 大量的任务需要执行的时候，延迟时间精度低
    *
    *  6 被动关闭定时任务
    *    订单创建好后，系统不做主动超时关闭的动作，当用户来访问订单的时候，系统判断订单是不是超过了过期时间，
    *   如果是就执行关闭订单操作，然后再提示用户
    *  优点：
    *    1 使用简单，无需任何的额外操作
    *  缺点：
    *    1 用户不查询此订单，就会出现很多脏数据冗余 2 查询操作中有写操作，某个时间点大量的写操作进来会给数据库带来压力
    *
    *
    *  总结：如果系统是单体应用，使用JDK自带延迟队列方式，因为实现起来简单
    *       如果数据量没有到达日均百万级别甚至千万级别、订单的延迟精度要求高的场景，采用RocketMQ方案或者redis方案。
    *       订单量数据量很大（日均百万级别甚至千万），精度要求没有那么高的场景建议采用任务中心的方案。
    *
    *
    *
    *
    *
    *
    * */
}
